# 자바 핵심 개념 정리
<details>
<summary>Java에서 제공하는 원시 타입들에 무엇이 있고, 각각 몇 바이트를 차지하나요?</summary>
<div markdown="1">
byte: 1바이트<br>
short: 2바이트<br>
int: 4바이트<br>
long: 8바이트<br>
float: 4바이트<br>
double: 8바이트<br>
boolean: 1비트<br>
char: 2바이트
</div>
</details>
<br>

<details>
<summary>오버라이딩(OverRiding)과 오버로딩(OverLoading)에 대해 설명해주세요.</summary>
<div markdown="1">
오버라이딩은 부모 클래스로부터 상속받은 함수를 재정의하는 것을 가리킨다.<br>
상속받은 원래의 함수와 함수 이름, 매개변수, 리턴값이 모두 같아야 하지만, 그 외 다른 세부 내용은 변경할 수 있다.<br>
오버로딩은 이름이 같은 함수가 매개변수에 따라 다르게 작동하도록 해야 할 때 사용한다.<br>
한 클래스 내에 동일한 이름을 가진 함수 여러 개를 정의하되, 매개변수가 서로 다르도록 한다.<br>
오버로딩을 사용하면 같은 이름의 함수를 호출하더라도 무슨 매개변수를 넘겨주느냐에 따라 서로 다른 작업을 하도록 할 수 있다.
</div>
</details>
<br>

<details>
<summary>객체지향 프로그래밍(OOP)에 대해 설명해주세요</summary>
<div markdown="1">
객체지향프로그래밍에서는 프로그램을 서로 독립된 개체인 객체로 나누어 파악한다. 그리고 그 객체들 사이의 상호작용을 다루는 방식으로 프로그래밍한다.<br>
</div>
</details>
<br>

<details>
<summary>추상 클래스와 인터페이스에 대해 설명해주시고, 차이에 대해 설명해주세요.</summary>
<div markdown="1">
추상 클래스와 인터페이스는 모두 상속을 통해 완성된다.<br>
이들 자체를 가지고는 new 연산자로 인스턴스를 만들어낼 수 없다. 이들을 상속한 구현체 클래스를 만들고, 그 구현체 클래스로 인스턴스를 만들어 사용한다.<br>
둘 모두 추상 메소드를 사용할 수 있다.<br>
둘을 상속한 구현체는 둘 안에 선언된 추상 메소드들을 빠짐없이 구현해야 한다.<br>
이 둘의 가장 큰 차이점은 다중 상속의 가능 여부이다.<br>
인터페이스는 문어발처럼 많은 구현체를 가질 수 있다.<br>
그러나 추상 클래스는 다중 상속이 불가능하다.<br>
따라서 인터페이스가 하나의 틀로 여러 구현체를 찍어내는 역할을 한다면, 추상 클래스는 나중에 완성할 수 있도록 미리 그려둔 스케치 한 장과 비슷하다.
</div>
</details>
<br>

<details>
<summary>가비지 컬렉션(gc)란 무엇일까요?</summary>
<div markdown="1">
가비지 컬렉션은 프로그램이 동적으로 할당했던 메모리 영역이 더이상 쓸모없게 되었을 때 이를 자동으로 해제해주는 기능이다.<br>
가비지 컬렉션 덕분에, 자바에서는 할당된 메모리를 일일이 해제해줄 필요가 없다.
</div>
</details>
<br>

<details>
<summary>JVM의 동작 방식에 대해 설명해 주세요.</summary>
<div markdown="1">
JVM은 자바 프로그램을 실행할 때 필요한 메모리를 실제 시스템으로부터 받아와, 그 안에서 프로그램을 실행한다. 이 데이터 공간은 runtime data area라고 부른다.<br>
인터프리터와 JIT compiler를 사용해, 자바 compiler가 번역해놓은 바이트 코드를 OS에 맞는 기계어로 번역한다. 덕분에 자바 코드는 어떤 OS에서든 실행 가능하다.<br>
가비지 컬렉션을 관리하는 역할도 한다.
</div>
</details>
<br>

<details>
<summary>불변 객체란 무엇이고, final은 무엇일까요? 사용하는 이유와 함께 설명해주세요.</summary>
<div markdown="1">
불변 객체는 내부의 데이터 내용을 변경할 수 없는 객체이다.<br>
아예 새로운 데이터를 재할당할 수는 있으나(즉 해당 변수가 다른 데이터를 참조하게 할 수는 있으나), 원래 있던 데이터의 내용을 변경할 수는 없다.<br>
final은 객체를 불변으로 만들어준다. String과 같이 애초부터 모든 객체가 불변인 타입도 있고, final을 붙였을 경우에만 불변 객체로 기능하는 타입도 있다.<br>
불변 객체의 내용을 꺼내오는 메소드는 객체의 내용 자체를 제공하는 것이 아니라, 내용을 복사하여 제공한다. 그래서 이렇게 가져온 내용을 수정해보아도 복사본만 수정될 뿐 본래 값은 변하지 않는다.<br>
불변 객체의 사용은 다음을 비롯한 많은 장점을 갖는다.<br>
먼저, 어떤 문제가 발생하든 해당 객체의 내용이 절대 바뀌지 않는다. 따라서 문제 발생 이전의 상태로 다시 객체를 되돌려놓아야 한다는 걱정이 사라진다.<br>
둘째로, 다른 사람의 코드를 가져와 코딩을 진행할 때 시간을 아낄 수 있다. 객체의 내부를 일일이 살펴보지 않아도 그 안의 내용이 처음 그대로일 것을 확신할 수 있기 때문이다.<br>
셋째로, 결과의 예측가능성이 증가한다. 객체 값 변경 때문에 결과가 바뀌는 일을 방지할 수 있기 때문이다.<br>
</div>
</details>
<br>

<details>
<summary>자바의 메모리 영역에 대해 설명해주세요.</summary>
<div markdown="1">
자바의 메모리 영역 (JVM의 runtime data area) 은 다섯 가지의 영역으로 나뉜다.<br>
JVM이 클래스 파일을 가져오면 다섯 개의 영역은 각각 다음과 같은 역할을 한다.<br>
Heap 영역: 참조형 객체나 배열 등의 경우, 참조를 하는 변수는 stack 영역에 저장되지만 참조를 당하는 실제 데이터는 heap 영역에 저장된다. 이곳의 데이터는 스레드가 끝나도 삭제되지 않고 계속 유지되다가, 전혀 호출당하지 않게 되면 가비지 컬렉션에 의해 사라진다.<br>
Method 영역 (Static 영역): 프로그램이 시작되는 순간부터 끝나는 순간까지 메모리에 남아있는 데이터들을 저장한다. 여기에는 런타임 상수 풀, 클래스의 필드들, 클래스의 static 변수들, 상수 즉 final 객체, 생성자, 메소드 등이 있다. static 데이터를 너무 많이 사용하면 이 공간의 메모리가 부족할 수 있기 때문에 코드를 짤 때 주의해야 한다.<br>
Stack 영역: 메소드의 지역변수 데이터를 저장한다. 원시 타입 지역변수와 매개변수를 저장한다. 한 메소드를 위한 스택 메모리 공간을 스택 프레임이라고 한다. 스택 프레임은 해당 메소드가 시작될 때 할당되고, 메소드가 종료되면 삭제된다.<br>
PC register 영역: JVM이 처리하고 있는 명령어가 실제 메모리 상에서 어느 주소에 있는지를 기록한다.<br>
Native method stacks 영역: C와 C++ 등, Java가 아닌 다른 언어로 구성된 메소드를 실행해야 할 때 사용되는 공간이다.
</div>
</details>
<br>

<details>
<summary>new String()과 리터럴(" ")의 차이에 대해 설명해주세요.</summary>
<div markdown="1">
new String()으로 생성된 문자열 객체는 Heap 메모리 상에 무조건 1대1로 공간을 할당받는다.<br>
반면, 리터럴로 생성된 문자열 객체는 Heap 메모리 안에있는 String Pool에서 데이터를 참조한다. 이때 자신의 데이터 값과 동일한 데이터가 String Pool에 이미 존재한다면 새로운 데이터를 생성하지 않고 있던 데이터를 참조한다.
</div>
</details>
<br>

<details>
<summary>⭐️ 추가 과제: 람다(lambda)에 대해 알아볼까요?</summary>
<div markdown="1">
람다란 익명 함수를 가리킨다.<br>
람다식의 이점은 다음과 같다.<br>
첫째, 불필요한 반복문을 삭제하고, 식을 단순하게 표현할 수 있다.<br>
둘째, 자연연산을 수행하여 불필요한 연산을 최소할 수 있다.<br>
셋째, 멀티스레드를 활용해 병렬처리를 사용할 수 있다.<br>
일반 함수식을 람다식으로 바꾸는 방법은 https://blowupmomo.tistory.com/200 에 정리하였다.
</div>
</details>
<br>

<details>
<summary>⭐️ 추가 과제: 스트림(stream)에 대해 알아볼까요?</summary>
<div markdown="1">
스트림의 정의는 '데이터 처리연산을 지원하도록 소스에서 추출된 연속된 요소'이다.<br>
스트림을 사용하면 간결하고 간편하게 데이터를 처리할 수 있다.<br>
스트림은 파이프라인 방식으로 데이터를 처리한다. filter, sorted 등의 중간연산들은 연산을 수행한 후 결과물로 스트림을 다시 리턴하는데, 이것을 받아 다음 연산에 바로 사용할 수 있다. 단, collect와 같은 최종연산을 사용하면 파이프라인이 끝난다.
</div>
</details>
<br>

